# 产品族

由用户挑选自己所需要的产品，动态装配出符合用户需要的软件功能。用户的需求表单可能是单参数的，例如通过不同按钮下的订单，orderType 就不同。
用户的需求也可能是分阶段，多参数的，例如用户可能先选了专车，然后又表达了自己需要儿童座椅。有很多种装配多个 Git 仓库成为产品族的方式，但是 Autonomy 有很大差异。

产品族问题也可以理解为“最终用户编程”问题，它本质上是用户来动态装配组件，而不是一种组合后的订单，一种组合后的商品，完全由程序员预编程好。

## 单字段：预组合

最简单的实现办法是添加一个代表类型的字段，例如 orderType。这种做法就是“预组合”，把所有的可能性都提前叉乘出来，变成单个变量。
这种做法有两个节点：

* 写入 orderType：如果和用户的按钮没有一一对应关系，在写入 orderType 的时候还需要有一个汇总多变量为单变量的逻辑
* 读取 orderType：所有需要差异性的地方，都要对 orderType 进行解读

也就是 orderType 成为把多个 Git 仓库粘合起来的一个东西，大家都认这个字段的含义。这种做法会有如下问题

* 难以支持分阶段表达的需求：比如用户下单的时候是一种类型，中途经过了机场，业务含义发生了变化怎么办？更新 orderType 吗？
* 难以添加新的 orderType：加了新的值，所有读取 orderType 的地方都要更新自己的判断逻辑
* 组合爆炸：如果变化的维度很多，叉乘出来的 orderType 可能是指数增长的

## 多字段：后组合

因为单字段的缺陷，所以实践中往往是一开始以单字段开局，然后很快地滑落为多字段的实现方案。然后又在两种方案中反复横跳

* 添加新的 orderType：可以加一个值同时代表很多含义，不用修改表结构
* 添加新的字段：不关心这个字段的Git仓库可以不改。然而如果很多Git仓库都关心这个字段，不仅仅都要修改，而且要改接口定义

为了避免频繁加字段，就出现了用一个 bit 来代表某个 feature 是否激活的搞法。搞一个 64bit 的 int64 字段可以代表 64 个 feature flag。

## 每个 Git 仓库定义自己的“合同”

除了多字段之外，还可以通过多表来实现组合。比如除了 Order，我们可以定义 OrderShipment 表，代表快递。定义 OrderSelfPickup 表，代表自提。
通过查找这个 order 是否在 OrderShipment 中，得知这个订单是否走快递配送，以及配送的目的地。
这种做法，相当于加 feature flag，每个新的变种，都是一个新的独立 bit。
也就是压根没有 xxxType 一说，只有一堆 isXXX 这样的 feature flag。
加字段，或者加表就是麻烦，单纯从 Autonomy 的角度来说，肯定是一堆独立的 Feature Flag 更独立自主。

多表可以理解为每个 Git 仓库定义了自己的“合同”，自己的业务记录在自己的合同内部，而不是都由“order”来夹带。
实践中，order经常变成 `Map<string, any>` 这样的玩意，就是所有新的业务，都要往 order 上夹带新私货。

面向对象编程发展多年，凝结出来的一句智慧是“用组合代替继承”。用多个表来组合，就是用多个对象来组合。
本质上可以理解为一个内存中的组合对象，持久化到多个数据库表中。

## 小结

如果判断变化不会很多，作用域控制在单个 Git 仓库内部，可以选择单字段的模式。如果预判将来会有各种幺蛾子，需要用来集成多个Git仓库，还是选择多字段，或者多表更不容易埋坑。