# 如何复用一套代码支持多样性的业务？

有太多的文章教你怎么组织代码了。但是这些文章大都是系统A，模块B的抽象写意派。虽然看着很有道理的样子，但就是看不懂。
本文的特点是有十多个带有具体业务场景的例子。从如何接新需求的角度来分析模块应该怎么拆分。

全文分为四个章节：

* 模块切分的好坏标准是什么？
* 这些经典的解决方案用了也就那样
* 松耦合的接口应该定义成什么样子？
* 为什么实际的业务代码都没有写成你说的那个样子？

# 模块切分的好坏标准是什么？

复用，以及支持多样性，都是同一个问题的不同表述。其实质问题是如何对系统进行模块分解。需要分成几个模块，模块之间的依赖关系是怎样的？下面通过四个具体的例子来说明。

## 公共模块应该稳定

[【阅读该例子】](./criteria-of-modularization/common-module-should-be-stable)

在 [Agile Software Development](https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/1292025948) 书中，Robert Martin 讲过了很重要的两个原则

* 越是被很多模块依赖的模块，越应该减少改动。道理很简单，底层模块一改，上层的模块必然受到影响。依赖关系的方向，就是“不稳定”依赖“稳定”的方向。
* Common Reuse Principle。要复用的模块不要把过多的东西捆绑，要复用就整体复用。

## 避免超级繁忙的顶层模块

[【阅读该例子】](./criteria-of-modularization/avoid-crazy-busy-top-module)

模块与模块之间的依赖关系，就是抽象与稳定的关系。但实践中，像“业务编排API”和“BFF”，你很难判断谁比谁更稳定，更抽象。当我们一个业务请求，需要经过一串模块的时候，往往是有问题的。因为当要做修改的时候，你会觉得在哪个环节拦一刀都有道理。David Parnas 在 [The Secret History of Information Hiding](https://www.researchgate.net/profile/David_Parnas/publication/200085877_On_the_Criteria_To_Be_Used_in_Decomposing_Systems_into_Modules/links/55956a7408ae99aa62c72622/On-the-Criteria-To-Be-Used-in-Decomposing-Systems-into-Modules.pdf?origin=publication_detail) 一文中也写道，他认为 Levels of Abstraction 是很难判断的。

这个例子应该怎样调整是合适的?分法有很多，可以按流程步骤分，可以按业务变化频率分，但从依赖关系的结构上来说，一定是这样的结构

* 一定是**多个模块**直接面向**多个业务方向**，每个模块承担一些，而不是集中把修改工作都压到一个顶层模块上
* 在这多个模块上面一定不能拿一个“业务收口”模块载往顶上套一层。所谓业务编排，其实就是业务编程。只要可以编程，就会抑制不住地往里面加东西。

不会因为把函数调用，改叫“业务编排”，就改变模块之间的依赖关系。依赖关系才是真正决定性因素。

## 通过新增模块来扩展功能

[【阅读该例子】](./criteria-of-modularization/extending-by-adding-new-module)

从这个例子里我们可以看到如下的规律

* 一个新功能要修改哪个模块取决于模块的依赖关系。typescript-language-features 在依赖关系里有 ts server，所以一些功能就得改它那里。
* 新增模块来实现新功能可以避免把给现有模块添加新的依赖，比如 mocha 这个依赖就只需要加到 mocha-test-explorer 上。是否新增一个模块，还是修改已有的模块，是否引入依赖是一个关键决策因素。

稍微有点经验程序员都能体会到 vscode 做为 Eric Gamma 大神在 eclipse 之后的又一力作，架构上是很优秀的。但可能只是感觉优秀，又说不出来优秀在哪里。通过这个例子，我们就可以看到，判断一个模块拆分结构是否优秀的唯一标准，就是看它如何处理需求的变更和新增。当所有的需求都要往一个模块里改的时候，这个拆分就是糟糕的。当新的需求往往可以通过新增模块来实现的时候，这个拆分结构就是优秀的。

## 要更关注“易变性”而不是“功能切分”

[【阅读该例子】](./criteria-of-modularization/more-focus-on-violatility-than-functionality)

这个例子说明了

* 按流程步骤切分未必是最优方案，“易变性”是更重要的可度量指标，其实看看 git 提交记录就知道了
* 前面三个例子都是说明不要把改动集中到一个模块里，这个其实相对好实现。极端情况下，每个函数，每一行代码都拆成一个模块就可以实现。
* 这个例子要说明的是反过来，如果一个需求要改动太多的模块，那也是有问题的。这个其实非常难以实现，但是是追求的目标。

## 模块切分的好坏标准

模块切分的出发点其实非常简单直白

* 如果所有的需求都要集中到一个模块去等排期，那必然会拖慢速度
  * 公共模块应该稳定
  * 避免超级繁忙的顶层模块
  * 通过新增模块来扩展功能
* 如果一个需求动辄就要数个模块联合开发和调试，那必然会拖慢速度
  * 要更关注“易变性”而不是“功能切分”

模块划分的静态结构无所谓好坏，只关注新需求如何修改或者新增的问题。
不用去争辩是应该大前台，还是大中台。代码量不是问题，圈复杂度也不是问题。
唯一度量的标准就是去看每个新需求都是怎么改出来的。

# 这些经典的解决方案用了也就那样

上一章提出的好坏标准有任何一条是新鲜的么? 一条都没有。
以前的文章可能例子举得少了一点，但是总结的原则都是差不多的。
那接下来的追问就是，如果原则一直都在那里，那为什么我们过去看过的代码都没遵守这些原则呢?
我有三个猜测

* 最容易想到的解决方案未必是最佳的方案
* 真正松耦合的接口定义形式并没有被大众所熟知
* 按照这些松耦合的接口去分解模块并不容易落地

我先来分析第一个猜想，列举几个最常见的解决方案。

## 用 interface 代替 class

