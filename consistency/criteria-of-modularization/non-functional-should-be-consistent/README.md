假设你有一个微服务架构，其中包含了前台业务模块，以及订单模块，策略模块，商家店铺模块。分别采用了 HTTP REST 接口，GRpc 接口，Thrift 接口。所有的 RPC 库都是用编程语言自带的网络库来完成的。其中 HTTP REST 接口更过分，是每一个不同的 URL 都有一份独立的调用代码。

这个时候需要来了一个需求，要统计上报接口错误率和延迟。所有协议的所有实现，都要修改一遍，添加上统计上报的代码。这里包括遍历所有的业务方法，找到 HTTP 调用的地方。

然后又来了一个需求，要对接口进行容错，对故障节点进行自动摘除。然后又要全文遍历一遍。

然后又来了一个需求，因为下游接入了弹性的云服务，不能使用域名进行服务发现，因为端口号会变化。于是又要改一遍所有的地方加上服务发现的代码。

然后又来了一个需求，需要对 RPC 调用进行染色，支持流量镜像等。需要在 RPC 协议中都加入一个 trace id 以及透传的字段，于是所有的 RPC 调用都要改一遍。

我们可以总结出以下规律：

* 非功能性需求有很强的复用性，不仅是可以独立出来，而且是必须独立出来。
* 破坏了 consistency，导致的就是重复实现，重复修改
* 本质上仍然是分工问题，破坏了 autonomy。如果所有的 RPC 框架都由基础架构负责，稳定性也有基础架构负责。那么可以由基础架构团队一方自主完成所有的工作。